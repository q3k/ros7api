package ros

import (
	"context"
	"encoding/json"
	"fmt"
)

// Automatically generated by github.com/q3k/ros7api/gen, do not edit.

type InterfaceBridgePort_Edge string

const (
	// same as no-discover, but will additionally detect if a bridge port is a Wireless interface with disabled bridge-mode, such interface will be automatically set as an edge port without discovery.
	InterfaceBridgePort_EdgeAuto = "auto"
	// non-edge port, will participate in learning and listening states in STP.
	InterfaceBridgePort_EdgeNo = "no"
	// non-edge port with enabled discovery, will participate in learning and listening states in STP, a port can become an edge port if no BPDU is received.
	InterfaceBridgePort_EdgeNoDiscover = "no-discover"
	// edge port without discovery, will transit directly to forwarding state.
	InterfaceBridgePort_EdgeYes = "yes"
	// edge port with enabled discovery, will transit directly to forwarding state.
	InterfaceBridgePort_EdgeYesDiscover = "yes-discover"
)

type InterfaceBridgePort_FrameTypes string

const (
	InterfaceBridgePort_FrameTypesAdmitAll                           = "admit-all"
	InterfaceBridgePort_FrameTypesAdmitOnlyUntaggedAndPriorityTagged = "admit-only-untagged-and-priority-tagged"
	InterfaceBridgePort_FrameTypesAdmitOnlyVlanTagged                = "admit-only-vlan-tagged"
)

type InterfaceBridgePort_Learn string

const (
	// enables MAC learning
	InterfaceBridgePort_LearnYes = "yes"
	// disables MAC learning
	InterfaceBridgePort_LearnNo = "no"
	// detects if bridge port is a Wireless interface and uses a Wireless registration table instead of MAC learning, will use Wireless registration table if the Wireless interface is set to one of ap-bridge, bridge, wds-slave mode and bridge mode for the Wireless interface is disabled.
	InterfaceBridgePort_LearnAuto = "auto"
)

type InterfaceBridgePort_MulticastRouter string

const (
	// disabled multicast router state on the bridge port. Unregistered multicast and IGMP/MLD membership reports are not sent to the bridge port regardless of what is connected to it.
	InterfaceBridgePort_MulticastRouterDisabled = "disabled"
	// enabled multicast router state on the bridge port. Unregistered multicast and IGMP/MLD membership reports are sent to the bridge port regardless of what is connected to it.
	InterfaceBridgePort_MulticastRouterPermanent = "permanent"
	// automatically detect multicast router state on the bridge port using IGMP/MLD queries.
	InterfaceBridgePort_MulticastRouterTemporaryQuery = "temporary-query"
)

type InterfaceBridgePort_PointToPoint string

const (
	InterfaceBridgePort_PointToPointAuto = "auto"
	InterfaceBridgePort_PointToPointYes  = "yes"
	InterfaceBridgePort_PointToPointNo   = "no"
)

// InterfaceBridgePort represents a ROS `interface/bridge/port` record, including read-only fields.
//
// Port submenu is used to add interfaces in a particular bridge.
type InterfaceBridgePort struct {
	Record

	// When enabled, prevents a port moving from discarding into forwarding state if no BPDUs are received from the neighboring bridge. The port will change into a forwarding state only when a BPDU is received. This property only has an effect when protocol-mode is set to rstp or mstp and edge is set to no.
	AutoIsolate Boolean `json:"auto-isolate"`
	// Enables or disables BPDU Guard feature on a port. This feature puts the port in a disabled role if it receives a BPDU and requires the port to be manually disabled and enabled if a BPDU was received. Should be used to prevent a bridge from BPDU related attacks. This property has no effect when protocol-mode is set to none.
	BpduGuard Boolean `json:"bpdu-guard"`
	// The bridge interface where the respective interface is grouped in.
	Bridge string `json:"bridge"`
	// When enabled, bridge floods broadcast traffic to all bridge egress ports. When disabled, drops broadcast traffic on egress ports. Can be used to filter all broadcast traffic on an egress port. Broadcast traffic is considered as traffic that uses FF:FF:FF:FF:FF:FF as destination MAC address, such traffic is crucial for many protocols such as DHCP, ARP, NDP, BOOTP (Netinstall), and others. This option does not limit traffic flood to the CPU.
	BroadcastFlood Boolean `json:"broadcast-flood"`
	// Set port as edge port or non-edge port, or enable edge discovery. Edge ports are connected to a LAN that has no other bridges attached. An edge port will skip the learning and the listening states in STP and will transition directly to the forwarding state, this reduces the STP initialization time. If the port is configured to discover edge port then as soon as the bridge detects a BPDU coming to an edge port, the port becomes a non-edge port. This property has no effect when protocol-mode is set to none.
	Edge InterfaceBridgePort_Edge `json:"edge"`
	// Enables IGMP/MLD fast leave feature on the bridge port. The bridge will stop forwarding multicast traffic to a bridge port when an IGMP/MLD leave message is received. This property only has an effect when igmp-snooping is set to yes.
	FastLeave Boolean `json:"fast-leave"`
	// Specifies allowed ingress frame types on a bridge port. This property only has an effect when vlan-filtering is set to yes.
	FrameTypes InterfaceBridgePort_FrameTypes `json:"frame-types"`
	// Enables or disables VLAN ingress filtering, which checks if the ingress port is a member of the received VLAN ID in the bridge VLAN table. Should be used with frame-types to specify if the ingress traffic should be tagged or untagged. This property only has effect when vlan-filtering is set to yes.
	IngressFiltering Boolean `json:"ingress-filtering"`
	// Changes MAC learning behavior on a bridge port
	Learn InterfaceBridgePort_Learn `json:"learn"`
	// A multicast router port is a port where a multicast router or querier is connected. On this port, unregistered multicast streams and IGMP/MLD membership reports will be sent. This setting changes the state of the multicast router for bridge ports. This property can be used to send IGMP/MLD membership reports to certain bridge ports for further multicast routing or proxying. This property only has an effect when igmp-snooping is set to yes.
	MulticastRouter InterfaceBridgePort_MulticastRouter `json:"multicast-router"`
	// Path cost to the interface for MSTI0 inside a region. This property only has effect when protocol-mode is set to mstp.
	InternalPathCost Number `json:"internal-path-cost"`
	// Name of the interface.
	Interface string `json:"interface"`
	// Path cost to the interface, used by STP to determine the best path, used by MSTP to determine the best path between regions. This property has no effect when protocol-mode is set to none.
	PathCost Number `json:"path-cost"`
	// Specifies if a bridge port is connected to a bridge using a point-to-point link for faster convergence in case of failure. By setting this property to yes, you are forcing the link to be a point-to-point link, which will skip the checking mechanism, which detects and waits for BPDUs from other devices from this single link. By setting this property to no, you are expecting that a link can receive BPDUs from multiple devices. By setting the property to yes, you are significantly improving (R/M)STP convergence time. In general, you should only set this property to no if it is possible that another device can be connected between a link, this is mostly relevant to Wireless mediums and Ethernet hubs. If the Ethernet link is full-duplex, auto enables point-to-point functionality. This property has no effect when protocol-mode is set to none.
	PointToPoint InterfaceBridgePort_PointToPoint `json:"point-to-point"`
	// The priority of the interface, used by STP to determine the root port, used by MSTP to determine root port between regions.
	Priority Number `json:"priority"`
	// Port VLAN ID (pvid) specifies which VLAN the untagged ingress traffic is assigned to. This property only has an effect when vlan-filtering is set to yes.
	Pvid Number `json:"pvid"`
	// Enable the restricted role on a port, used by STP to forbid a port from becoming a root port. This property only has an effect when protocol-mode is set to mstp.
	RestrictedRole Boolean `json:"restricted-role"`
	// Disable topology change notification (TCN) sending on a port, used by STP to forbid network topology changes to propagate. This property only has an effect when protocol-mode is set to mstp.
	RestrictedTCN Boolean `json:"restricted-tcn"`
	// Forces all packets to be treated as untagged packets. Packets on ingress port will be tagged with another VLAN tag regardless if a VLAN tag already exists, packets will be tagged with a VLAN ID that matches the pvid value and will use EtherType that is specified in ether-type. This property only has effect when vlan-filtering is set to yes.
	TagStacking Boolean `json:"tag-stacking"`
	// When enabled, it allows forwarding DHCP packets towards the DHCP server through this port. Mainly used to limit unauthorized servers to provide malicious information for users. This property only has an effect when dhcp-snooping is set to yes.
	Trusted Boolean `json:"trusted"`
	// Changes the multicast flood option on bridge port, only controls the egress traffic. When enabled, the bridge allows flooding multicast packets to the specified bridge port, but when disabled, the bridge restricts multicast traffic from being flooded to the specified bridge port. The setting affects all multicast traffic, this includes non-IP, IPv4, IPv6 and the link-local multicast ranges (e.g. 224.0.0.0/24 and ff02::1). Note that when igmp-snooping is enabled and IGMP/MLD querier is detected, the bridge will automatically restrict unknown IP multicast from being flooded, so the setting is not mandatory for IGMP/MLD snooping setups. When using this setting together with igmp-snooping, the only multicast traffic that is allowed on the bridge port is the known multicast from the MDB table.
	UnknownMulticastFlood Boolean `json:"unknown-multicast-flood"`
	// Changes the unknown unicast flood option on bridge port, only controls the egress traffic. When enabled, the bridge allows flooding unknown unicast packets to the specified bridge port, but when disabled, the bridge restricts unknown unicast traffic from being flooded to the specified bridge port. If a MAC address is not learned in the host table, then the traffic is considered as unknown unicast traffic and will be flooded to all ports. MAC address is learned as soon as a packet on a bridge port is received and the source MAC address is added to the bridge host table. Since it is required for the bridge to receive at least one packet on the bridge port to learn the MAC address, it is recommended to use static bridge host entries to avoid packets being dropped until the MAC address has been learned.
	UnknownUnicastFlood Boolean `json:"unknown-unicast-flood"`
}

// InterfaceBridgePort_Update is an update to a ROS `interface/bridge/port` record. Any unset field will not be updated.
type InterfaceBridgePort_Update struct {
	// When enabled, prevents a port moving from discarding into forwarding state if no BPDUs are received from the neighboring bridge. The port will change into a forwarding state only when a BPDU is received. This property only has an effect when protocol-mode is set to rstp or mstp and edge is set to no.
	AutoIsolate *Boolean `json:"auto-isolate,omitempty"`
	// Enables or disables BPDU Guard feature on a port. This feature puts the port in a disabled role if it receives a BPDU and requires the port to be manually disabled and enabled if a BPDU was received. Should be used to prevent a bridge from BPDU related attacks. This property has no effect when protocol-mode is set to none.
	BpduGuard *Boolean `json:"bpdu-guard,omitempty"`
	// The bridge interface where the respective interface is grouped in.
	Bridge *string `json:"bridge,omitempty"`
	// When enabled, bridge floods broadcast traffic to all bridge egress ports. When disabled, drops broadcast traffic on egress ports. Can be used to filter all broadcast traffic on an egress port. Broadcast traffic is considered as traffic that uses FF:FF:FF:FF:FF:FF as destination MAC address, such traffic is crucial for many protocols such as DHCP, ARP, NDP, BOOTP (Netinstall), and others. This option does not limit traffic flood to the CPU.
	BroadcastFlood *Boolean `json:"broadcast-flood,omitempty"`
	// Set port as edge port or non-edge port, or enable edge discovery. Edge ports are connected to a LAN that has no other bridges attached. An edge port will skip the learning and the listening states in STP and will transition directly to the forwarding state, this reduces the STP initialization time. If the port is configured to discover edge port then as soon as the bridge detects a BPDU coming to an edge port, the port becomes a non-edge port. This property has no effect when protocol-mode is set to none.
	Edge *InterfaceBridgePort_Edge `json:"edge,omitempty"`
	// Enables IGMP/MLD fast leave feature on the bridge port. The bridge will stop forwarding multicast traffic to a bridge port when an IGMP/MLD leave message is received. This property only has an effect when igmp-snooping is set to yes.
	FastLeave *Boolean `json:"fast-leave,omitempty"`
	// Specifies allowed ingress frame types on a bridge port. This property only has an effect when vlan-filtering is set to yes.
	FrameTypes *InterfaceBridgePort_FrameTypes `json:"frame-types,omitempty"`
	// Enables or disables VLAN ingress filtering, which checks if the ingress port is a member of the received VLAN ID in the bridge VLAN table. Should be used with frame-types to specify if the ingress traffic should be tagged or untagged. This property only has effect when vlan-filtering is set to yes.
	IngressFiltering *Boolean `json:"ingress-filtering,omitempty"`
	// Changes MAC learning behavior on a bridge port
	Learn *InterfaceBridgePort_Learn `json:"learn,omitempty"`
	// A multicast router port is a port where a multicast router or querier is connected. On this port, unregistered multicast streams and IGMP/MLD membership reports will be sent. This setting changes the state of the multicast router for bridge ports. This property can be used to send IGMP/MLD membership reports to certain bridge ports for further multicast routing or proxying. This property only has an effect when igmp-snooping is set to yes.
	MulticastRouter *InterfaceBridgePort_MulticastRouter `json:"multicast-router,omitempty"`
	// Path cost to the interface for MSTI0 inside a region. This property only has effect when protocol-mode is set to mstp.
	InternalPathCost *Number `json:"internal-path-cost,omitempty"`
	// Name of the interface.
	Interface *string `json:"interface,omitempty"`
	// Path cost to the interface, used by STP to determine the best path, used by MSTP to determine the best path between regions. This property has no effect when protocol-mode is set to none.
	PathCost *Number `json:"path-cost,omitempty"`
	// Specifies if a bridge port is connected to a bridge using a point-to-point link for faster convergence in case of failure. By setting this property to yes, you are forcing the link to be a point-to-point link, which will skip the checking mechanism, which detects and waits for BPDUs from other devices from this single link. By setting this property to no, you are expecting that a link can receive BPDUs from multiple devices. By setting the property to yes, you are significantly improving (R/M)STP convergence time. In general, you should only set this property to no if it is possible that another device can be connected between a link, this is mostly relevant to Wireless mediums and Ethernet hubs. If the Ethernet link is full-duplex, auto enables point-to-point functionality. This property has no effect when protocol-mode is set to none.
	PointToPoint *InterfaceBridgePort_PointToPoint `json:"point-to-point,omitempty"`
	// The priority of the interface, used by STP to determine the root port, used by MSTP to determine root port between regions.
	Priority *Number `json:"priority,omitempty"`
	// Port VLAN ID (pvid) specifies which VLAN the untagged ingress traffic is assigned to. This property only has an effect when vlan-filtering is set to yes.
	Pvid *Number `json:"pvid,omitempty"`
	// Enable the restricted role on a port, used by STP to forbid a port from becoming a root port. This property only has an effect when protocol-mode is set to mstp.
	RestrictedRole *Boolean `json:"restricted-role,omitempty"`
	// Disable topology change notification (TCN) sending on a port, used by STP to forbid network topology changes to propagate. This property only has an effect when protocol-mode is set to mstp.
	RestrictedTCN *Boolean `json:"restricted-tcn,omitempty"`
	// Forces all packets to be treated as untagged packets. Packets on ingress port will be tagged with another VLAN tag regardless if a VLAN tag already exists, packets will be tagged with a VLAN ID that matches the pvid value and will use EtherType that is specified in ether-type. This property only has effect when vlan-filtering is set to yes.
	TagStacking *Boolean `json:"tag-stacking,omitempty"`
	// When enabled, it allows forwarding DHCP packets towards the DHCP server through this port. Mainly used to limit unauthorized servers to provide malicious information for users. This property only has an effect when dhcp-snooping is set to yes.
	Trusted *Boolean `json:"trusted,omitempty"`
	// Changes the multicast flood option on bridge port, only controls the egress traffic. When enabled, the bridge allows flooding multicast packets to the specified bridge port, but when disabled, the bridge restricts multicast traffic from being flooded to the specified bridge port. The setting affects all multicast traffic, this includes non-IP, IPv4, IPv6 and the link-local multicast ranges (e.g. 224.0.0.0/24 and ff02::1). Note that when igmp-snooping is enabled and IGMP/MLD querier is detected, the bridge will automatically restrict unknown IP multicast from being flooded, so the setting is not mandatory for IGMP/MLD snooping setups. When using this setting together with igmp-snooping, the only multicast traffic that is allowed on the bridge port is the known multicast from the MDB table.
	UnknownMulticastFlood *Boolean `json:"unknown-multicast-flood,omitempty"`
	// Changes the unknown unicast flood option on bridge port, only controls the egress traffic. When enabled, the bridge allows flooding unknown unicast packets to the specified bridge port, but when disabled, the bridge restricts unknown unicast traffic from being flooded to the specified bridge port. If a MAC address is not learned in the host table, then the traffic is considered as unknown unicast traffic and will be flooded to all ports. MAC address is learned as soon as a packet on a bridge port is received and the source MAC address is added to the bridge host table. Since it is required for the bridge to receive at least one packet on the bridge port to learn the MAC address, it is recommended to use static bridge host entries to avoid packets being dropped until the MAC address has been learned.
	UnknownUnicastFlood *Boolean `json:"unknown-unicast-flood,omitempty"`
}

// InterfaceBridgePortList returns a list of all `interface/bridge/port` records.
func (c *Client) InterfaceBridgePortList(ctx context.Context) ([]InterfaceBridgePort, error) {
	body, err := c.doGET(ctx, "interface/bridge/port")
	if err != nil {
		return nil, fmt.Errorf("could not GET: %w", err)
	}
	defer body.Close()

	var target []InterfaceBridgePort
	if err := json.NewDecoder(body).Decode(&target); err != nil {
		return nil, fmt.Errorf("could not decode JSON: %w", err)
	}
	return target, nil
}

// InterfaceBridgePortPatch updates the given fields of a `interface/bridge/port` record by ID.
func (c *Client) InterfaceBridgePortPatch(ctx context.Context, id RecordID, u *InterfaceBridgePort_Update) (*InterfaceBridgePort, error) {
	rdata, err := json.Marshal(u)
	if err != nil {
		return nil, fmt.Errorf("could not marshal update: %w", err)
	}
	body, err := c.doPATCH(ctx, "interface/bridge/port/"+string(id), rdata)
	if err != nil {
		return nil, fmt.Errorf("could not PATCH: %w", err)
	}
	defer body.Close()

	var target struct {
		InterfaceBridgePort
		Error   int64  `json:"error"`
		Message string `json:"message"`
		Detail  string `json:"detail"`
	}
	if err := json.NewDecoder(body).Decode(&target); err != nil {
		return nil, fmt.Errorf("could not decode JSON: %w", err)
	}
	if target.Error != 0 {
		return nil, fmt.Errorf("server error: %s: %s", target.Message, target.Detail)
	}
	return &target.InterfaceBridgePort, nil
}
