package ros

import (
	"context"
	"encoding/json"
	"fmt"
)

// Automatically generated by github.com/q3k/ros7api/gen, do not edit.

// InterfaceBridgeVlan represents a ROS `interface/bridge/vlan` record, including read-only fields.
//
// Bridge VLAN table represents per-VLAN port mapping with an egress VLAN tag action. The tagged ports send out frames with a corresponding VLAN ID tag. The untagged ports remove a VLAN tag before sending out frames. Bridge ports with frame-types set to admit-all or admit-only-untagged-and-priority-tagged will be automatically added as untagged ports for the pvid VLAN.
type InterfaceBridgeVlan struct {
	Record

	// The bridge interface which the respective VLAN entry is intended for.
	Bridge string `json:"bridge"`
	// Enables or disables Bridge VLAN entry.
	Disabled Boolean `json:"disabled"`
	// Interface list with a VLAN tag adding action in egress.
	Tagged StringList `json:"tagged"`
	// Interface list with a VLAN tag removing action in egress.
	Untagged StringList `json:"untagged"`
	// The list of VLAN IDs for certain port configuration.
	VlanIDs         Number     `json:"vlan-ids"`
	CurrentTagged   StringList `json:"current-tagged"`
	CurrentUntagged StringList `json:"current-untagged"`
	Dynamic         Boolean    `json:"dynamic"`
}

// InterfaceBridgeVlan_Update is an update to a ROS `interface/bridge/vlan` record. Any unset field will not be updated.
type InterfaceBridgeVlan_Update struct {
	// The bridge interface which the respective VLAN entry is intended for.
	Bridge *string `json:"bridge,omitempty"`
	// Enables or disables Bridge VLAN entry.
	Disabled *Boolean `json:"disabled,omitempty"`
	// Interface list with a VLAN tag adding action in egress.
	Tagged *StringList `json:"tagged,omitempty"`
	// Interface list with a VLAN tag removing action in egress.
	Untagged *StringList `json:"untagged,omitempty"`
	// The list of VLAN IDs for certain port configuration.
	VlanIDs *Number `json:"vlan-ids,omitempty"`
}

// InterfaceBridgeVlanList returns a list of all `interface/bridge/vlan` records.
func (c *Client) InterfaceBridgeVlanList(ctx context.Context) ([]InterfaceBridgeVlan, error) {
	body, err := c.doGET(ctx, "interface/bridge/vlan")
	if err != nil {
		return nil, fmt.Errorf("could not GET: %w", err)
	}
	defer body.Close()

	var target []InterfaceBridgeVlan
	if err := json.NewDecoder(body).Decode(&target); err != nil {
		return nil, fmt.Errorf("could not decode JSON: %w", err)
	}
	return target, nil
}

// InterfaceBridgeVlanPatch updates the given fields of a `interface/bridge/vlan` record by ID.
func (c *Client) InterfaceBridgeVlanPatch(ctx context.Context, id RecordID, u *InterfaceBridgeVlan_Update) (*InterfaceBridgeVlan, error) {
	rdata, err := json.Marshal(u)
	if err != nil {
		return nil, fmt.Errorf("could not marshal update: %w", err)
	}
	body, err := c.doPATCH(ctx, "interface/bridge/vlan/"+string(id), rdata)
	if err != nil {
		return nil, fmt.Errorf("could not PATCH: %w", err)
	}
	defer body.Close()

	var target struct {
		InterfaceBridgeVlan
		Error   int64  `json:"error"`
		Message string `json:"message"`
		Detail  string `json:"detail"`
	}
	if err := json.NewDecoder(body).Decode(&target); err != nil {
		return nil, fmt.Errorf("could not decode JSON: %w", err)
	}
	if target.Error != 0 {
		return nil, fmt.Errorf("server error: %s: %s", target.Message, target.Detail)
	}
	return &target.InterfaceBridgeVlan, nil
}
